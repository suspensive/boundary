{"version":3,"sources":["../src/AsyncBoundary.tsx","../src/ErrorBoundary.tsx","../src/ErrorBoundaryGroup.tsx","../src/hooks/useIsChanged.ts","../src/hooks/useIsClient.ts","../src/hooks/useIsomorphicLayoutEffect.ts","../src/hooks/usePrevious.ts","../src/hooks/useTimeout.ts","../src/utils/assert.ts","../src/utils/hasResetKeysChanged.ts","../src/Delay.tsx","../src/Suspense.tsx","../src/wrap.tsx"],"sourcesContent":["import type { ComponentProps, ComponentRef, ComponentType, SuspenseProps } from 'react'\nimport { forwardRef } from 'react'\nimport { ErrorBoundary } from './ErrorBoundary'\nimport type { ErrorBoundaryProps } from './ErrorBoundary'\nimport { Suspense } from './Suspense'\nimport type { PropsWithoutChildren } from './types'\n\n/**\n * @deprecated Use SuspenseProps and ErrorBoundaryProps as alternatives\n */\nexport type AsyncBoundaryProps = Omit<SuspenseProps, 'fallback'> &\n  Omit<ErrorBoundaryProps, 'fallback'> & {\n    pendingFallback?: SuspenseProps['fallback']\n    rejectedFallback: ErrorBoundaryProps['fallback']\n  }\n\nconst BaseAsyncBoundary = forwardRef<ComponentRef<typeof ErrorBoundary>, AsyncBoundaryProps>(\n  ({ pendingFallback, rejectedFallback, children, ...errorBoundaryProps }, resetRef) => (\n    <ErrorBoundary {...errorBoundaryProps} ref={resetRef} fallback={rejectedFallback}>\n      <Suspense fallback={pendingFallback}>{children}</Suspense>\n    </ErrorBoundary>\n  )\n)\nif (process.env.NODE_ENV !== 'production') {\n  BaseAsyncBoundary.displayName = 'AsyncBoundary'\n}\nconst CSROnly = forwardRef<ComponentRef<typeof ErrorBoundary>, AsyncBoundaryProps>(\n  ({ pendingFallback, rejectedFallback, children, ...errorBoundaryProps }, resetRef) => (\n    <ErrorBoundary {...errorBoundaryProps} ref={resetRef} fallback={rejectedFallback}>\n      <Suspense.CSROnly fallback={pendingFallback}>{children}</Suspense.CSROnly>\n    </ErrorBoundary>\n  )\n)\nif (process.env.NODE_ENV !== 'production') {\n  CSROnly.displayName = 'AsyncBoundary.CSROnly'\n}\n\n/**\n * @deprecated Use `<Suspense/>` and `<ErrorBoundary/>` as alternatives\n */\nexport const AsyncBoundary = Object.assign(BaseAsyncBoundary, {\n  /**\n   * @deprecated Use `<Suspense/>` and `<ErrorBoundary/>` as alternatives\n   */\n  CSROnly,\n})\n\n/**\n * @deprecated Use wrap.ErrorBoundary().Suspense().on as alternatives\n */\nexport const withAsyncBoundary = Object.assign(\n  <TProps extends ComponentProps<ComponentType> = Record<string, never>>(\n    Component: ComponentType<TProps>,\n    asyncBoundaryProps: PropsWithoutChildren<AsyncBoundaryProps>\n  ) => {\n    const Wrapped = (props: TProps) => (\n      <AsyncBoundary {...asyncBoundaryProps}>\n        <Component {...props} />\n      </AsyncBoundary>\n    )\n\n    if (process.env.NODE_ENV !== 'production') {\n      const name = Component.displayName || Component.name || 'Component'\n      Wrapped.displayName = `withAsyncBoundary(${name})`\n    }\n\n    return Wrapped\n  },\n  {\n    /**\n     * @deprecated Use wrap.ErrorBoundary().Suspense.CSROnly().on as alternatives\n     */\n    CSROnly: <TProps extends ComponentProps<ComponentType> = Record<string, never>>(\n      Component: ComponentType<TProps>,\n      asyncBoundaryProps: PropsWithoutChildren<AsyncBoundaryProps>\n    ) => {\n      const Wrapped = (props: TProps) => (\n        <AsyncBoundary.CSROnly {...asyncBoundaryProps}>\n          <Component {...props} />\n        </AsyncBoundary.CSROnly>\n      )\n\n      if (process.env.NODE_ENV !== 'production') {\n        const name = Component.displayName || Component.name || 'Component'\n        Wrapped.displayName = `withAsyncBoundary.CSROnly(${name})`\n      }\n\n      return Wrapped\n    },\n  }\n)\n","import type { ComponentProps, ComponentType, ErrorInfo, FunctionComponent, PropsWithChildren, ReactNode } from 'react'\nimport { Component, createContext, forwardRef, useContext, useImperativeHandle, useMemo, useRef, useState } from 'react'\nimport { ErrorBoundaryGroupContext } from './ErrorBoundaryGroup'\nimport type { PropsWithoutChildren } from './types'\nimport { assert, hasResetKeysChanged } from './utils'\nimport { wrap } from './wrap'\n\nexport type ErrorBoundaryFallbackProps<TError extends Error = Error> = {\n  /**\n   * when ErrorBoundary catch error, you can use this error\n   */\n  error: TError\n  /**\n   * when you want to reset caught error, you can use this reset\n   */\n  reset: () => void\n}\n\nexport type ErrorBoundaryProps = PropsWithChildren<{\n  /**\n   * an array of elements for the ErrorBoundary to check each render. If any of those elements change between renders, then the ErrorBoundary will reset the state which will re-render the children\n   */\n  resetKeys?: unknown[]\n  /**\n   * when ErrorBoundary is reset by resetKeys or fallback's props.reset, onReset will be triggered\n   */\n  onReset?(): void\n  /**\n   * when ErrorBoundary catch error, onError will be triggered\n   */\n  onError?(error: Error, info: ErrorInfo): void\n  /**\n   * when ErrorBoundary catch error, fallback will be render instead of children\n   */\n  fallback: ReactNode | FunctionComponent<ErrorBoundaryFallbackProps>\n}>\n\ntype ErrorBoundaryState<TError extends Error = Error> =\n  | {\n      isError: true\n      error: TError\n    }\n  | {\n      isError: false\n      error: null\n    }\n\nconst initialErrorBoundaryState: ErrorBoundaryState = {\n  isError: false,\n  error: null,\n}\nclass BaseErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { isError: true, error }\n  }\n\n  state = initialErrorBoundaryState\n\n  componentDidUpdate(prevProps: ErrorBoundaryProps, prevState: ErrorBoundaryState) {\n    const { isError } = this.state\n    const { resetKeys } = this.props\n    if (isError && prevState.isError && hasResetKeysChanged(prevProps.resetKeys, resetKeys)) {\n      this.reset()\n    }\n  }\n\n  componentDidCatch(error: Error, info: ErrorInfo) {\n    this.props.onError?.(error, info)\n  }\n\n  reset = () => {\n    this.props.onReset?.()\n    this.setState(initialErrorBoundaryState)\n  }\n\n  render() {\n    const { children, fallback } = this.props\n\n    if (this.state.isError && typeof fallback === 'undefined') {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('ErrorBoundary of @suspensive/react requires a defined fallback')\n      }\n      throw this.state.error\n    }\n\n    let childrenOrFallback = children\n    if (this.state.isError) {\n      if (typeof fallback === 'function') {\n        const FallbackComponent = fallback\n        childrenOrFallback = <FallbackComponent error={this.state.error} reset={this.reset} />\n      } else {\n        childrenOrFallback = fallback\n      }\n    }\n    return (\n      <ErrorBoundaryContext.Provider value={{ ...this.state, reset: this.reset }}>\n        {childrenOrFallback}\n      </ErrorBoundaryContext.Provider>\n    )\n  }\n}\n\n/**\n * This component provide a simple and reusable wrapper that you can use to wrap around your components. Any rendering errors in your components hierarchy can then be gracefully handled.\n * @see {@link https://suspensive.org/docs/react/ErrorBoundary}\n */\nexport const ErrorBoundary = forwardRef<{ reset(): void }, ErrorBoundaryProps>((props, ref) => {\n  const group = useContext(ErrorBoundaryGroupContext) ?? { resetKey: 0 }\n  const resetKeys = [group.resetKey, ...(props.resetKeys || [])]\n\n  const baseErrorBoundaryRef = useRef<BaseErrorBoundary>(null)\n  useImperativeHandle(ref, () => ({\n    reset: () => baseErrorBoundaryRef.current?.reset(),\n  }))\n\n  return <BaseErrorBoundary {...props} resetKeys={resetKeys} ref={baseErrorBoundaryRef} />\n})\nif (process.env.NODE_ENV !== 'production') {\n  ErrorBoundary.displayName = 'ErrorBoundary'\n}\n\n/**\n * @deprecated Use wrap.ErrorBoundary().on as alternatives\n */\nexport const withErrorBoundary = <TProps extends ComponentProps<ComponentType> = Record<string, never>>(\n  component: ComponentType<TProps>,\n  errorBoundaryProps: PropsWithoutChildren<ErrorBoundaryProps>\n) => wrap.ErrorBoundary(errorBoundaryProps).on(component)\n\nconst ErrorBoundaryContext = createContext<({ reset: () => void } & ErrorBoundaryState) | null>(null)\n\nexport const useErrorBoundary = <TError extends Error = Error>() => {\n  const [state, setState] = useState<ErrorBoundaryState<TError>>({\n    isError: false,\n    error: null,\n  })\n  if (state.isError) {\n    throw state.error\n  }\n\n  const errorBoundary = useContext(ErrorBoundaryContext)\n  assert(errorBoundary != null && !errorBoundary.isError, assert.message.useErrorBoundary.onlyInChildrenOfErrorBoundary)\n\n  return useMemo(\n    () => ({\n      setError: (error: TError) => setState({ isError: true, error }),\n    }),\n    []\n  )\n}\n\nexport const useErrorBoundaryFallbackProps = <TError extends Error = Error>(): ErrorBoundaryFallbackProps<TError> => {\n  const errorBoundary = useContext(ErrorBoundaryContext)\n  assert(\n    errorBoundary != null && errorBoundary.isError,\n    assert.message.useErrorBoundaryFallbackProps.onlyInFallbackOfErrorBoundary\n  )\n\n  return useMemo(\n    () => ({\n      error: errorBoundary.error as TError,\n      reset: errorBoundary.reset,\n    }),\n    [errorBoundary.error, errorBoundary.reset]\n  )\n}\n","import type { ComponentProps, ComponentType, PropsWithChildren } from 'react'\nimport { createContext, useContext, useEffect, useMemo, useReducer } from 'react'\nimport { useIsChanged } from './hooks'\nimport type { PropsWithoutChildren } from './types'\nimport { assert } from './utils'\nimport { wrap } from './wrap'\n\nexport const ErrorBoundaryGroupContext = createContext<{ reset: () => void; resetKey: number } | undefined>(undefined)\nif (process.env.NODE_ENV !== 'production') {\n  ErrorBoundaryGroupContext.displayName = 'ErrorBoundaryGroupContext'\n}\n\nexport type ErrorBoundaryGroupProps = PropsWithChildren<{\n  /**\n   * If you use blockOutside as true, ErrorBoundaryGroup will protect multiple ErrorBoundaries as its children from external ErrorBoundaryGroup's resetKey\n   * @default false\n   */\n  blockOutside?: boolean\n}>\n\nconst increase = (prev: number) => prev + 1\n\n/**\n * ErrorBoundaryGroup is Component to manage multiple ErrorBoundaries\n * @see {@link https://suspensive.org/docs/react/ErrorBoundaryGroup}\n */\nexport const ErrorBoundaryGroup = ({ blockOutside = false, children }: ErrorBoundaryGroupProps) => {\n  const [resetKey, reset] = useReducer(increase, 0)\n  const parentGroup = useContext(ErrorBoundaryGroupContext)\n  const isParentGroupResetKeyChanged = useIsChanged(parentGroup?.resetKey)\n\n  useEffect(() => {\n    if (!blockOutside && isParentGroupResetKeyChanged) {\n      reset()\n    }\n  }, [isParentGroupResetKeyChanged, blockOutside])\n\n  const value = useMemo(() => ({ reset, resetKey }), [resetKey])\n\n  return <ErrorBoundaryGroupContext.Provider value={value}>{children}</ErrorBoundaryGroupContext.Provider>\n}\nif (process.env.NODE_ENV !== 'production') {\n  ErrorBoundaryGroup.displayName = 'ErrorBoundaryGroup'\n}\n\nconst ErrorBoundaryGroupReset = ({\n  trigger: Trigger,\n}: {\n  /**\n   * When you want to reset multiple ErrorBoundaries as children of ErrorBoundaryGroup, You can combine any other components with this trigger's reset\n   */\n  trigger: ComponentType<ReturnType<typeof useErrorBoundaryGroup>>\n}) => {\n  const errorBoundaryGroup = useErrorBoundaryGroup()\n\n  return <Trigger reset={errorBoundaryGroup.reset} />\n}\n\nErrorBoundaryGroup.Reset = ErrorBoundaryGroupReset\n\nexport const useErrorBoundaryGroup = () => {\n  const group = useContext(ErrorBoundaryGroupContext)\n  assert(group != null, assert.message.useErrorBoundaryGroup.onlyInChildrenOfErrorBoundaryGroup)\n  return useMemo(\n    () => ({\n      /**\n       * When you want to reset multiple ErrorBoundaries as children of ErrorBoundaryGroup, You can use this reset\n       */\n      reset: group.reset,\n    }),\n    [group.reset]\n  )\n}\n\n/**\n * @deprecated Use wrap.ErrorBoundaryGroup().on as alternatives\n */\nexport const withErrorBoundaryGroup = <TProps extends ComponentProps<ComponentType> = Record<string, never>>(\n  component: ComponentType<TProps>,\n  errorBoundaryGroupProps: PropsWithoutChildren<ErrorBoundaryGroupProps> = {}\n) => wrap.ErrorBoundaryGroup(errorBoundaryGroupProps).on(component)\n","import { usePrevious } from '.'\n\nexport const useIsChanged = (value: unknown) => usePrevious(value) !== value\n","import { useState } from 'react'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect'\n\nexport const useIsClient = () => {\n  const [isClient, setIsClient] = useState(false)\n\n  useIsomorphicLayoutEffect(() => {\n    setIsClient(true)\n  }, [])\n\n  return isClient\n}\n","import { useEffect, useLayoutEffect } from 'react'\nexport const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect\n","import { useEffect, useRef } from 'react'\n\nexport const usePrevious = <TValue>(value: TValue): TValue => {\n  const ref = useRef<TValue>(value)\n\n  useEffect(() => {\n    ref.current = value\n  }, [value])\n\n  return ref.current\n}\n","import { useEffect, useRef } from 'react'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect'\n\nexport const useTimeout = (fn: () => void, ms: number) => {\n  const fnRef = useRef(fn)\n\n  useIsomorphicLayoutEffect(() => {\n    fnRef.current = fn\n  }, [fn])\n\n  useEffect(() => {\n    const id = setTimeout(fnRef.current, ms)\n    return () => clearTimeout(id)\n  }, [ms])\n}\n","export function assert(condition: boolean, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(message)\n  }\n}\n\nassert.message = {\n  useErrorBoundary: {\n    onlyInChildrenOfErrorBoundary: 'useErrorBoundary: this hook should be called in ErrorBoundary.props.children',\n  },\n  useErrorBoundaryFallbackProps: {\n    onlyInFallbackOfErrorBoundary:\n      'useErrorBoundaryFallbackProps: this hook should be called in ErrorBoundary.props.fallback',\n  },\n  useErrorBoundaryGroup: {\n    onlyInChildrenOfErrorBoundaryGroup:\n      'useErrorBoundaryGroup: this hook should be called in ErrorBoundaryGroup.props.children',\n  },\n} as const\n","export const hasResetKeysChanged = (a: unknown[] = [], b: unknown[] = []) =>\n  a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]))\n","import type { ComponentProps, ComponentType, PropsWithChildren } from 'react'\nimport { createContext, useContext, useState } from 'react'\nimport { useTimeout } from './hooks'\nimport type { PropsWithoutChildren } from './types'\nimport { wrap } from './wrap'\n\nexport type DelayProps = PropsWithChildren<{\n  ms?: number\n}>\n\nexport const Delay = ({ ms, children }: DelayProps) => {\n  const delayContextValue = useContext(DelayContext)\n  const delayMs = ms ?? delayContextValue.ms ?? 0\n  const [isDelayed, setIsDelayed] = useState(delayMs === 0)\n  useTimeout(() => setIsDelayed(true), delayMs)\n  return <>{isDelayed ? children : null}</>\n}\nif (process.env.NODE_ENV !== 'production') {\n  Delay.displayName = 'Delay'\n}\n\nexport const DelayContext = createContext<PropsWithoutChildren<DelayProps>>({ ms: 0 })\n\n/**\n * @deprecated Use wrap.Delay().on as alternatives\n */\nexport const withDelay = <TProps extends ComponentProps<ComponentType> = Record<string, never>>(\n  component: ComponentType<TProps>,\n  delayProps: PropsWithoutChildren<DelayProps> = {}\n) => wrap.Delay(delayProps).on(component)\n","import type { ComponentProps, ComponentType, ReactNode, SuspenseProps as ReactSuspenseProps } from 'react'\nimport { Suspense as ReactSuspense, createContext, useContext } from 'react'\nimport { useIsClient } from './hooks'\nimport type { PropsWithoutChildren } from './types'\nimport { wrap } from './wrap'\n\nexport type SuspenseProps = ReactSuspenseProps\n\nexport const SuspenseContext = createContext<PropsWithoutChildren<SuspenseProps>>({ fallback: undefined })\nconst useFallbackWithContext = (fallback: ReactNode) => {\n  const contextFallback = useContext(SuspenseContext).fallback\n\n  return fallback === null ? null : fallback ?? contextFallback\n}\n\nconst DefaultSuspense = (props: SuspenseProps) => {\n  const fallback = useFallbackWithContext(props.fallback)\n\n  return <ReactSuspense {...props} fallback={fallback} />\n}\nif (process.env.NODE_ENV !== 'production') {\n  DefaultSuspense.displayName = 'Suspense'\n}\nconst CSROnly = (props: SuspenseProps) => {\n  const isClient = useIsClient()\n  const fallback = useFallbackWithContext(props.fallback)\n\n  return isClient ? <ReactSuspense {...props} fallback={fallback} /> : <>{fallback}</>\n}\nif (process.env.NODE_ENV !== 'production') {\n  CSROnly.displayName = 'Suspense.CSROnly'\n}\n\n/**\n * This component is just wrapping React's Suspense. to use Suspense easily in Server-side rendering environment like Next.js\n * @see {@link https://suspensive.org/docs/react/Suspense}\n */\nexport const Suspense = Object.assign(DefaultSuspense, {\n  /**\n   * CSROnly make Suspense can be used in SSR framework like Next.js with React 17 or under\n   * @see {@link https://suspensive.org/docs/react/Suspense}\n   */\n  CSROnly,\n})\n\n/**\n * @deprecated Use wrap.Suspense().on as alternatives\n */\nexport const withSuspense = Object.assign(\n  <TProps extends ComponentProps<ComponentType> = Record<string, never>>(\n    component: ComponentType<TProps>,\n    suspenseProps: PropsWithoutChildren<SuspenseProps> = {}\n  ) => wrap.Suspense(suspenseProps).on(component),\n  {\n    /**\n     * @deprecated Use wrap.Suspense.CSROnly().on as alternatives\n     */\n    CSROnly: <TProps extends ComponentProps<ComponentType> = Record<string, never>>(\n      component: ComponentType<TProps>,\n      suspenseProps: PropsWithoutChildren<SuspenseProps> = {}\n    ) => wrap.Suspense.CSROnly(suspenseProps).on(component),\n  }\n)\n","import type { ComponentProps, ComponentType } from 'react'\nimport type { PropsWithoutChildren } from './types'\nimport { Delay, ErrorBoundary, ErrorBoundaryGroup, Suspense } from '.'\n\ntype WrapperItem<\n  TWrapperComponent extends\n    | typeof Suspense\n    | typeof Suspense.CSROnly\n    | typeof ErrorBoundary\n    | typeof ErrorBoundaryGroup\n    | typeof Delay,\n> = [TWrapperComponent, PropsWithoutChildren<ComponentProps<TWrapperComponent>>]\n\ntype Wrapper =\n  | WrapperItem<typeof Suspense>\n  | WrapperItem<typeof Suspense.CSROnly>\n  | WrapperItem<typeof ErrorBoundary>\n  | WrapperItem<typeof ErrorBoundaryGroup>\n  | WrapperItem<typeof Delay>\n\nclass WrapWithoutCSROnly {\n  constructor(private wrappers: Wrapper[]) {}\n  Suspense = (props: PropsWithoutChildren<ComponentProps<typeof Suspense>> = {}) => {\n    this.wrappers.unshift([Suspense, props])\n    return this\n  }\n  ErrorBoundary = (props: PropsWithoutChildren<ComponentProps<typeof ErrorBoundary>>) => {\n    this.wrappers.unshift([ErrorBoundary, props])\n    return this\n  }\n  ErrorBoundaryGroup = (props: PropsWithoutChildren<ComponentProps<typeof ErrorBoundaryGroup>> = {}) => {\n    this.wrappers.unshift([ErrorBoundaryGroup, props])\n    return this\n  }\n  Delay = (props: PropsWithoutChildren<ComponentProps<typeof Delay>> = {}) => {\n    this.wrappers.unshift([Delay, props])\n    return this\n  }\n\n  on = <TProps extends ComponentProps<ComponentType>>(Component: ComponentType<TProps>) => {\n    const WrappedComponent = (props: TProps) =>\n      this.wrappers.reduce(\n        (acc, [WrapperComponent, wrapperProps]) => (\n          <WrapperComponent {...(wrapperProps as any)}>{acc}</WrapperComponent>\n        ),\n        <Component {...props} />\n      )\n\n    if (process.env.NODE_ENV !== 'production') {\n      WrappedComponent.displayName = this.wrappers.reduce(\n        (acc, [WrapperComponent]) => `with${WrapperComponent.displayName}(${acc})`,\n        Component.displayName || Component.name || 'Component'\n      )\n    }\n\n    return WrappedComponent\n  }\n}\n\ntype Wrap = WrapWithoutCSROnly & {\n  Suspense: WrapWithoutCSROnly['Suspense'] & {\n    CSROnly: (props?: PropsWithoutChildren<ComponentProps<typeof Suspense.CSROnly>>) => Wrap\n  }\n}\n\nconst createWrap = () => {\n  const wrappers: Wrapper[] = []\n  const wrap = new WrapWithoutCSROnly(wrappers) as Wrap\n  wrap.Suspense.CSROnly = (props: PropsWithoutChildren<ComponentProps<typeof Suspense.CSROnly>> = {}) => {\n    wrappers.unshift([Suspense.CSROnly, props])\n    return wrap\n  }\n  return wrap\n}\n\nconst wrapSuspense = (props: PropsWithoutChildren<ComponentProps<typeof Suspense>> = {}) => createWrap().Suspense(props)\nwrapSuspense.CSROnly = (props: PropsWithoutChildren<ComponentProps<typeof Suspense.CSROnly>> = {}) =>\n  createWrap().Suspense.CSROnly(props)\nconst wrapErrorBoundary = (props: PropsWithoutChildren<ComponentProps<typeof ErrorBoundary>>) =>\n  createWrap().ErrorBoundary(props)\nconst wrapErrorBoundaryGroup = (props: PropsWithoutChildren<ComponentProps<typeof ErrorBoundaryGroup>>) =>\n  createWrap().ErrorBoundaryGroup(props)\nconst wrapDelay = (props: PropsWithoutChildren<ComponentProps<typeof Delay>> = {}) => createWrap().Delay(props)\n\nexport const wrap = {\n  Suspense: wrapSuspense,\n  ErrorBoundary: wrapErrorBoundary,\n  ErrorBoundaryGroup: wrapErrorBoundaryGroup,\n  Delay: wrapDelay,\n}\n"],"mappings":"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","names":["import_react","import_react","import_react","import_react","import_react","import_react","import_react","import_react","import_jsx_runtime","ReactSuspense","import_jsx_runtime","Component","wrap","import_jsx_runtime","import_jsx_runtime","_a","import_jsx_runtime","CSROnly","Component"]}